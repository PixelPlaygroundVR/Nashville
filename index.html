<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pixel Playgrounds Nashville</title>
  <style>
    /* Reset and base styles */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Courier New', Courier, monospace;
      color: #00ffcc;
    }
    /* Fullscreen canvas for Three.js */
    canvas {
      display: block;
    }
    /* Overlay title with dripping neon effect */
    #overlay {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }
    #title {
      font-size: 3em;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #ff00cc;
      text-shadow: 0 0 10px #ff00cc, 0 0 20px #ff00cc;
      animation: drip 3s infinite alternate;
    }
    @keyframes drip {
      0%   { text-shadow: 0 0 10px #ff00cc, 0 0 20px #ff00cc; }
      100% { text-shadow: 0 20px 10px #ff00cc, 0 40px 20px #ff00cc; }
    }
    /* Scanline overlay for AR-style effect */
    #scanlines {
      pointer-events: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        180deg,
        rgba(0, 0, 0, 0) 0,
        rgba(0, 0, 0, 0) 2px,
        rgba(0, 0, 0, 0.2) 2px,
        rgba(0, 0, 0, 0.2) 4px
      );
      mix-blend-mode: overlay;
      animation: flicker 2s infinite;
      z-index: 20;
    }
    @keyframes flicker {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.6; }
    }
  </style>
</head>
<body>
  <!-- Overlay Title -->
  <div id="overlay">
    <h1 id="title">Pixel Playgrounds Nashville</h1>
  </div>
  <!-- AR Scanline Overlay -->
  <div id="scanlines"></div>
  <!-- Three.js will use this canvas -->
  <canvas id="webgl-canvas"></canvas>
  <!-- Background cyberpunk synthwave track (replace URL as desired) -->
  <audio id="bg-music" loop autoplay volume="0.2">
    <source src="YOUR_CYBERPUNK_SYNTHWAVE_TRACK_URL.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <!-- Glitch sound on button interaction -->
  <audio id="glitch-sound">
    <source src="https://www.myinstants.com/media/sounds/sci-fi-glitch.mp3" type="audio/mpeg">
  </audio>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- Main Script -->
  <script>
    /********************
     * Scene Setup
     ********************/
    const canvas = document.getElementById('webgl-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    // Camera setup: a perspective camera with a slightly elevated angle
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 5, 15);

    /********************
     * Lighting
     ********************/
    // Ambient light for overall illumination
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    // Point light to accentuate neon glow
    const pointLight = new THREE.PointLight(0xff00cc, 1, 50);
    pointLight.position.set(0, 10, 10);
    scene.add(pointLight);

    /********************
     * Custom Shader for Drippy/Liquid Metal Effect
     ********************/
    // A basic custom shader that distorts UV coordinates over time.
    const drippyShader = {
      uniforms: {
        time: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        uniform float time;
        void main() {
          vUv = uv;
          vec3 pos = position;
          // Simple sine wave distortion for a liquid metal vibe
          pos.y += sin(pos.x * 5.0 + time * 2.0) * 0.2;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        void main() {
          // Mix neon pink and cyan for a futuristic glow
          gl_FragColor = vec4(mix(vec3(1.0, 0.0, 0.8), vec3(0.0, 1.0, 0.8), vUv.y), 1.0);
        }
      `
    };

    /********************
     * Voxel Playground Core
     ********************/
    // Create a group to hold the playground voxel models
    const playground = new THREE.Group();

    // Create a custom voxel playground model (slides, swings, platforms)
    // For demonstration, we build a few boxes arranged in a playful structure.
    const voxelSize = 0.8;
    const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);

    // Use the custom shader material for drippy neon effect
    const voxelMaterial = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.clone(drippyShader.uniforms),
      vertexShader: drippyShader.vertexShader,
      fragmentShader: drippyShader.fragmentShader,
      wireframe: true
    });

    // Build a simple structure: a grid of voxels with some random height variation.
    const gridSize = 5;
    for (let x = -gridSize; x <= gridSize; x++) {
      for (let z = -gridSize; z <= gridSize; z++) {
        const voxel = new THREE.Mesh(geometry, voxelMaterial.clone());
        // Randomly adjust height to simulate slides/platforms
        voxel.position.set(x * voxelSize * 1.2, Math.random() * 1.5, z * voxelSize * 1.2);
        playground.add(voxel);
      }
    }
    playground.position.y = 2;
    scene.add(playground);

    /********************
     * Interactive 3D Buttons
     ********************/
    const buttonGroup = new THREE.Group();
    scene.add(buttonGroup);

    // Button definitions with labels and target URLs (update these URLs!)
    const buttonsData = [
      { label: 'Shopify', url: 'YOUR_SHOPIFY_URL' },
      { label: 'Instagram', url: 'YOUR_INSTAGRAM_URL' },
      { label: 'Facebook', url: 'YOUR_FACEBOOK_URL' },
      { label: 'Installations', url: 'tel:+16156064969' }
    ];

    // Create a cube geometry for buttons
    const buttonGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);

    // Create an array to store button meshes and their orbit phases
    const buttons = [];
    buttonsData.forEach((btnData, index) => {
      const btnMaterial = new THREE.ShaderMaterial({
        uniforms: THREE.UniformsUtils.clone(drippyShader.uniforms),
        vertexShader: drippyShader.vertexShader,
        fragmentShader: drippyShader.fragmentShader,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      const buttonMesh = new THREE.Mesh(buttonGeometry, btnMaterial);
      buttonMesh.userData = {
        url: btnData.url,
        label: btnData.label,
        orbitPhase: index * (Math.PI / 2) // even phase offset
      };
      buttonGroup.add(buttonMesh);
      buttons.push(buttonMesh);
    });

    // Raycaster for interaction detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Glitch sound element
    const glitchSound = document.getElementById('glitch-sound');

    // Handle pointer move for hover effects
    function onPointerMove(event) {
      // Normalize mouse coordinates (-1 to 1)
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }
    window.addEventListener('pointermove', onPointerMove);

    // Handle pointer down for clicking buttons
    window.addEventListener('pointerdown', () => {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(buttons);
      if (intersects.length > 0) {
        const btn = intersects[0].object;
        // Trigger interaction animation: scale, rotate, burst particles (simplified here)
        btn.scale.set(1.5, 1.5, 1.5);
        // Play glitch sound
        glitchSound.currentTime = 0;
        glitchSound.play();
        // Open the URL after a short delay (to let the animation kick in)
        setTimeout(() => {
          window.location.href = btn.userData.url;
        }, 300);
      }
    });

    /********************
     * Cyberpunk Voxel Skyline Background
     ********************/
    const skyline = new THREE.Group();
    // Create a simple voxel skyline along the bottom of the scene
    const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
    for (let i = -15; i < 15; i++) {
      const building = new THREE.Mesh(buildingGeo, voxelMaterial.clone());
      // Random building height
      building.scale.y = Math.random() * 5 + 2;
      building.position.set(i * 1.2, building.scale.y / 2 - 1.5, -10);
      skyline.add(building);
    }
    scene.add(skyline);

    // Pixel virus effect (simple vertical oscillation to simulate disintegration)
    function updateSkyline(time) {
      skyline.children.forEach(building => {
        building.position.y = (Math.sin(time + building.position.x) * 0.5) + (building.scale.y / 2 - 1.5);
      });
    }

    /********************
     * Neon Glyph Particle Rain
     ********************/
    // Create a particle system of neon glyphs (0s, 1s, and 'PPN')
    const particleCount = 200;
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = [];
    const glyphs = [];
    for (let i = 0; i < particleCount; i++) {
      positions.push(
        (Math.random() - 0.5) * 30,
        Math.random() * 20,
        (Math.random() - 0.5) * 30
      );
      // Randomly assign a glyph (this demo does not render text but could be extended with sprite textures)
      const glyphOptions = [0, 1, 'PPN'];
      glyphs.push(glyphOptions[Math.floor(Math.random() * glyphOptions.length)]);
    }
    particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const particlesMaterial = new THREE.PointsMaterial({ color: 0x00ffcc, size: 0.5 });
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);

    /********************
     * Spinning Orbital Ring with Glowing Glyphs
     ********************/
    const ringGeometry = new THREE.TorusGeometry(4.5, 0.1, 16, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xff00cc, wireframe: true });
    const orbitalRing = new THREE.Mesh(ringGeometry, ringMaterial);
    orbitalRing.rotation.x = Math.PI / 2;
    scene.add(orbitalRing);

    /********************
     * Drifting Cyber-Orbs
     ********************/
    const cyberOrbs = [];
    const orbGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const orbMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
    for (let i = 0; i < 10; i++) {
      const orb = new THREE.Mesh(orbGeometry, orbMaterial.clone());
      orb.position.set(
        (Math.random() - 0.5) * 20,
        Math.random() * 10,
        (Math.random() - 0.5) * 20
      );
      scene.add(orb);
      cyberOrbs.push(orb);
    }

    /********************
     * Animation Loop
     ********************/
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();

      // Update custom shader uniform (for drippy effects)
      playground.children.forEach(voxel => {
        if (voxel.material.uniforms) {
          voxel.material.uniforms.time.value = elapsed;
        }
      });
      buttons.forEach(btn => {
        if (btn.material.uniforms) {
          btn.material.uniforms.time.value = elapsed;
        }
      });

      // Rotate and pulse the playground
      playground.rotation.y += 0.005;
      const pulse = 1 + 0.05 * Math.sin(elapsed * 3);
      playground.scale.set(pulse, pulse, pulse);

      // Animate orbiting buttons on an elliptical path
      buttons.forEach((btn) => {
        // Only orbit if not currently enlarged from interaction
        if (btn.scale.x < 1.6) {
          const phase = elapsed + btn.userData.orbitPhase;
          const a = 6; // semi-major axis
          const b = 3; // semi-minor axis
          btn.position.set(a * Math.cos(phase), 2, b * Math.sin(phase));
          btn.rotation.y += 0.02;
        } else {
          // Gradually return to original scale after interaction
          btn.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
        }
      });

      // Update skyline effect
      updateSkyline(elapsed);

      // Animate orbital ring
      orbitalRing.rotation.z += 0.01;

      // Animate cyber orbs drifting and pulsing
      cyberOrbs.forEach((orb, index) => {
        orb.position.x += Math.sin(elapsed + index) * 0.005;
        orb.position.y += Math.cos(elapsed + index) * 0.005;
        const scale = 1 + 0.2 * Math.sin(elapsed * 2 + index);
        orb.scale.set(scale, scale, scale);
      });

      // Simple particle rain effect: make particles fall and reset at a certain height
      const positionsAttr = particles.geometry.attributes.position;
      for (let i = 0; i < positionsAttr.count; i++) {
        positionsAttr.array[i * 3 + 1] -= 0.02;
        if (positionsAttr.array[i * 3 + 1] < 0) {
          positionsAttr.array[i * 3 + 1] = 20;
        }
      }
      positionsAttr.needsUpdate = true;

      renderer.render(scene, camera);
    }
    animate();

    /********************
     * Responsive Resize
     ********************/
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    /********************
     * Mobile Touch Controls (Optional Enhancements)
     ********************/
    // Consider integrating touch-based controls for mobile (e.g., using pointer events to pan the camera)
    // For brevity, this demo uses basic pointer move events already.
  </script>
</body>
</html>
